<!DOCTYPE html>
<html data-n-head="" data-n-head-ssr>
  <head>
    <meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1" name="viewport"><meta data-n-head="true" content="Freelance front-end web developer producing high quality work with an exceptional eye for detail. Mentor. Lover of JavaScript." name="description" data-hid="description"><meta data-n-head="true" content="IE=edge" http-equiv="X-UA-Compatible"><meta data-n-head="true" content="index,follow" name="robots"><title data-n-head="true">Understanding JavaScript Prototypes</title><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="https://use.typekit.net/nsr0hmh.css" rel="stylesheet" data-n-head="true"><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet" data-n-head="true"><script src="//assets.codepen.io/assets/embed/ei.js" async data-n-head="true"></script><link href="/_nuxt/manifest.5665c98e4df93fca61f1.js" rel="preload" as="script"><link href="/_nuxt/vendor.7d001ce926a227b17f6c.js" rel="preload" as="script"><link href="/_nuxt/app.6fd2de9b8344bde49f5d.js" rel="preload" as="script"><link href="/_nuxt/layouts/default.678975d957cfa76f41ed.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/_slug.144bb6835d0d840d4d5c.js" rel="preload" as="script"><link href="/_nuxt/app.d2c33f3f4e05c08b5cbc4a280a569c71.css" rel="preload" as="style"><link href="/_nuxt/pages/index.d5fab062fac5d1d83981.js" rel="prefetch"><link href="/_nuxt/pages/about.f6274d864e61cd0ebfe4.js" rel="prefetch"><link href="/_nuxt/pages/contact.14616812609860bae67c.js" rel="prefetch"><link href="/_nuxt/pages/blog/index.6fdf75d1b92ef77b0742.js" rel="prefetch"><link href="/_nuxt/pages/blade.606c5b429261dec543b7.js" rel="prefetch"><link href="/_nuxt/pages/404.3942ebb26a4a0e25d988.js" rel="prefetch"><link href="/_nuxt/10.565ebbab1afd5ee46077.js" rel="prefetch"><link href="/_nuxt/app.d2c33f3f4e05c08b5cbc4a280a569c71.css" rel="stylesheet">
  </head>
  <body data-n-head="">
    <div id="__nuxt" data-server-rendered="true"><div id="__layout"><div class="Page"><div class="BlogToolbar"><div style="display:none"><div></div><div><button class="BlogToolbar-backToTop BlogToolbar-button" title="Back to top"><svg viewBox="0 0 205 328" xmlns="http://www.w3.org/2000/svg"><path d="M195.7 94.8c-3.1 3.1-8 3-11.3 0L110 28.4V313c0 4.4-3.6 8-8 8s-8-3.6-8-8V28.4L19.6 94.7c-3.4 2.9-8.1 3.2-11.2.1-3.1-3.1-3.3-8.5-.1-11.4 0 0 87-79.2 88-80S99.1 1 102 1s4.9 1.6 5.7 2.4 88 80 88 80c1.5 1.5 2.3 3.6 2.3 5.7s-.8 4.1-2.3 5.7z"></path></svg></button></div></div></div><div class="Sidebar"><div class="Sidebar-inner"><!----><a href="/blog/medium-style-images" class="SidebarButton u-mb3"><span class="SidebarButton-upper">Previous:</span><span class="SidebarButton-lower">Medium style image loading</span></a><div class="Sidebar-social u-textCenter"><ul class="IconList"><li class="IconList-item"><a href="http://codepen.io/anthonykoch" class="IconList-link" title="Codepen"><svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M241.239 303.936c-15.322-10.357-30.742-20.569-46.062-30.93-2.03-1.373-3.43-1.472-5.502-.029l-38.871 26.154C181.966 319.905 244 361.317 244 361.317v-53.786c-.012-1.224-1.553-2.78-2.761-3.595zM195.092 240.666c15.454-10.16 30.851-20.409 46.109-30.86 1.486-1.018 2.775-3.509 2.799-5.334v-51.706s-62.033 41.124-93.262 61.942c13.7 9.159 26.671 17.913 39.787 26.443 1.02.662 3.396.284 4.567-.485zM269.838 209.354a4521.517 4521.517 0 0 0 47.627 31.815c.916.604 2.92.602 3.839 0l39.751-26.467L268 152.484v53.35c.01 1.201.805 2.821 1.838 3.52zM258.109 230.369c-1.21-.802-3.611-.528-4.743.168-4.817 2.962-9.463 6.203-14.164 9.355-8.248 5.53-25.356 17.023-25.356 17.023l38.842 25.865c1.748 1.157 4.436 1.22 6.26.111l39.014-25.993c.001 0-34.079-22.701-39.853-26.529zM141 237.116v39.609l29.622-19.838z"></path><path d="M256 32C132.288 32 32 132.288 32 256s100.288 224 224 224 224-100.288 224-224S379.712 32 256 32zm139 265.006c0 5.785-2.652 9.868-7.511 13.094a38019.909 38019.909 0 0 0-123.286 82.188c-5.854 3.918-11.174 3.754-16.984-.137-40.783-27.314-81.719-54.546-122.625-81.676-5.11-3.389-7.594-7.557-7.594-13.73v-79.729c0-6.141 2.521-10.332 7.624-13.716 40.906-27.13 81.939-54.363 122.724-81.676 5.818-3.896 11.094-4.007 16.938-.095a41090.004 41090.004 0 0 0 123.261 82.195c4.678 3.106 7.453 6.943 7.453 12.66v80.622z"></path><path d="M316.247 273.234a3826.352 3826.352 0 0 1-45.386 30.332c-2.412 1.588-2.888 3.318-2.861 6.189v51.346l93.039-62.004-38.527-25.882c-2.345-1.604-3.93-1.567-6.265.019zM370 276.676V237.06l-29.59 19.873z"></path></svg></a><li class="IconList-item"><a href="https://github.com/anthonykoch" class="IconList-link" title="Github"><svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M178.354,287.478c-9.123,0-16.928,4.207-23.201,12.833c-6.291,8.478-9.398,18.973-9.398,31.431 c0,12.474,3.166,23.008,9.398,31.509c6.273,8.54,14.039,12.771,23.201,12.771c8.494,0,15.889-4.27,22.121-12.771 c6.271-8.501,9.398-19.035,9.398-31.509c0-12.419-3.166-22.93-9.398-31.431C194.242,291.724,186.908,287.478,178.354,287.478z"></path><path d="M334.668,287.478c-9.045,0-16.891,4.207-23.182,12.833c-6.271,8.478-9.359,18.973-9.359,31.431 c0,12.474,3.186,23.008,9.359,31.509c6.291,8.54,14.098,12.771,23.182,12.771c8.533,0,15.906-4.27,22.178-12.771 c6.293-8.501,9.418-19.035,9.418-31.509c0-12.419-3.164-22.93-9.418-31.431C350.574,291.724,343.299,287.478,334.668,287.478z"></path><path d="M445.777,172h-0.059c0,0,2.793-14.264,0.314-39.18c-2.182-24.916-7.471-47.838-16.123-68.82 c0,0-4.422,0.76-12.76,2.896s-22.08,6.299-40.938,14.768c-18.541,8.54-37.986,19.788-58.297,33.505 c-13.803-3.934-34.408-5.939-61.994-5.939c-26.289,0-46.914,2.012-61.977,5.945c-44.592-30.859-81.832-47.945-112.092-51.175 c-8.594,20.982-13.883,43.991-16.045,68.97c-2.398,24.939,0.432,39.329,0.432,39.329C41.979,198.551,32,236.541,32,267.793 c0,24.244,0.658,46.078,6.125,65.48c5.564,19.31,12.662,35.13,21.098,47.221c8.611,12.121,19.012,22.788,31.576,31.938 c12.467,9.314,23.988,15.962,34.389,20.216c10.461,4.372,22.375,7.602,35.982,9.861c13.33,2.386,23.438,3.645,30.477,3.996 c0,0,28,1.494,64.354,1.494c36.354,0,64.295-1.494,64.295-1.494c7.02-0.352,17.145-1.634,30.535-3.996 c13.547-2.299,25.521-5.607,35.941-9.861c10.402-4.293,21.943-10.901,34.469-20.216c12.523-9.032,22.906-19.739,31.518-31.938 c8.436-12.091,15.494-27.911,21.098-47.221c5.486-19.402,6.145-41.385,6.145-65.629C480,237.389,469.982,199,445.777,172z M380.383,405.645C352.521,418.736,311.486,424,257.061,424l-2.143-0.039c-54.443,0-95.361-5.248-122.848-18.41 c-27.508-13.092-41.271-40.057-41.271-80.738c0-24.33,8.572-43.99,25.482-59.107c7.354-6.515,16.438-11.019,27.645-13.717 c11.129-2.558,21.354-2.762,30.969-2.465c9.398,0.415,22.551,2.196,39.344,3.464C231.029,254.285,243.535,256,256,256 c11.698,0,27.213-1.957,52.104-3.959c24.99-1.971,43.494-2.971,55.467-1c12.289,2.002,22.986,6.202,32.129,14.742 c17.734,15.751,26.602,35.505,26.602,59.084C422.301,365.533,408.164,392.537,380.383,405.645z"></path></svg></a><li class="IconList-item"><a href="https://twitter.com/anthkoch" class="IconList-link" title="Twitter"><svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M492 109.5c-17.4 7.7-36 12.9-55.6 15.3 20-12 35.4-31 42.6-53.6-18.7 11.1-39.4 19.2-61.5 23.5C399.8 75.8 374.6 64 346.8 64c-53.5 0-96.8 43.4-96.8 96.9 0 7.6.8 15 2.5 22.1-80.5-4-151.9-42.6-199.6-101.3-8.3 14.3-13.1 31-13.1 48.7 0 33.6 17.2 63.3 43.2 80.7-16-.4-31-4.8-44-12.1v1.2c0 47 33.4 86.1 77.7 95-8.1 2.2-16.7 3.4-25.5 3.4-6.2 0-12.3-.6-18.2-1.8 12.3 38.5 48.1 66.5 90.5 67.3-33.1 26-74.9 41.5-120.3 41.5-7.8 0-15.5-.5-23.1-1.4C62.8 432 113.7 448 168.3 448 346.6 448 444 300.3 444 172.2c0-4.2-.1-8.4-.3-12.5C462.6 146 479 129 492 109.5z"></path></svg></a></ul></div></div></div><div class="Page-inner"><div><header class="SiteHeader has-blogBackground is-collapsed" data-page="TODO" role="banner"><div class="SiteHeader-container"><div class="Logo"><a href="/" class="Logo-link u-px6 is-dark is-fixed is-active"><span>Anthony </span><span>Koch</span></a></div><nav class="SiteNav" role="navigation"><ul class="SiteNav-list"><li class="SiteNav-listItem"><a href="/#work" class="SiteNav-link is-dark">
            work
          </a><li class="SiteNav-listItem"><a href="/blog" class="SiteNav-link is-dark">
            blog
          </a><li class="SiteNav-listItem"><a href="/contact" class="SiteNav-link is-dark">
            contact
          </a><li class="SiteNav-listItem has-icon"><a href="https://github.com/anthonykoch?tab=repositories" class="SiteNav-iconLink is-github is-dark" rel="noopener noreferrer" target="_blank"><svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" fill="rgba(255,255,255,0.8)"><path d="M178.354,287.478c-9.123,0-16.928,4.207-23.201,12.833c-6.291,8.478-9.398,18.973-9.398,31.431 c0,12.474,3.166,23.008,9.398,31.509c6.273,8.54,14.039,12.771,23.201,12.771c8.494,0,15.889-4.27,22.121-12.771 c6.271-8.501,9.398-19.035,9.398-31.509c0-12.419-3.166-22.93-9.398-31.431C194.242,291.724,186.908,287.478,178.354,287.478z"></path><path d="M334.668,287.478c-9.045,0-16.891,4.207-23.182,12.833c-6.271,8.478-9.359,18.973-9.359,31.431 c0,12.474,3.186,23.008,9.359,31.509c6.291,8.54,14.098,12.771,23.182,12.771c8.533,0,15.906-4.27,22.178-12.771 c6.293-8.501,9.418-19.035,9.418-31.509c0-12.419-3.164-22.93-9.418-31.431C350.574,291.724,343.299,287.478,334.668,287.478z"></path><path d="M445.777,172h-0.059c0,0,2.793-14.264,0.314-39.18c-2.182-24.916-7.471-47.838-16.123-68.82 c0,0-4.422,0.76-12.76,2.896s-22.08,6.299-40.938,14.768c-18.541,8.54-37.986,19.788-58.297,33.505 c-13.803-3.934-34.408-5.939-61.994-5.939c-26.289,0-46.914,2.012-61.977,5.945c-44.592-30.859-81.832-47.945-112.092-51.175 c-8.594,20.982-13.883,43.991-16.045,68.97c-2.398,24.939,0.432,39.329,0.432,39.329C41.979,198.551,32,236.541,32,267.793 c0,24.244,0.658,46.078,6.125,65.48c5.564,19.31,12.662,35.13,21.098,47.221c8.611,12.121,19.012,22.788,31.576,31.938 c12.467,9.314,23.988,15.962,34.389,20.216c10.461,4.372,22.375,7.602,35.982,9.861c13.33,2.386,23.438,3.645,30.477,3.996 c0,0,28,1.494,64.354,1.494c36.354,0,64.295-1.494,64.295-1.494c7.02-0.352,17.145-1.634,30.535-3.996 c13.547-2.299,25.521-5.607,35.941-9.861c10.402-4.293,21.943-10.901,34.469-20.216c12.523-9.032,22.906-19.739,31.518-31.938 c8.436-12.091,15.494-27.911,21.098-47.221c5.486-19.402,6.145-41.385,6.145-65.629C480,237.389,469.982,199,445.777,172z M380.383,405.645C352.521,418.736,311.486,424,257.061,424l-2.143-0.039c-54.443,0-95.361-5.248-122.848-18.41 c-27.508-13.092-41.271-40.057-41.271-80.738c0-24.33,8.572-43.99,25.482-59.107c7.354-6.515,16.438-11.019,27.645-13.717 c11.129-2.558,21.354-2.762,30.969-2.465c9.398,0.415,22.551,2.196,39.344,3.464C231.029,254.285,243.535,256,256,256 c11.698,0,27.213-1.957,52.104-3.959c24.99-1.971,43.494-2.971,55.467-1c12.289,2.002,22.986,6.202,32.129,14.742 c17.734,15.751,26.602,35.505,26.602,59.084C422.301,365.533,408.164,392.537,380.383,405.645z"></path></svg></a></ul></nav></div><div class="SiteHeader-lower"></div></header><div class="Page-content has-sidebar"><article class="Post" id="post"><div class="Post__container"><header class="Post-header u-gutter"><div class="u-sizeReadable u-mxauto"><h1 class="Post-title"><a href="/blog/understanding-javascript-prototypes" class="Link is-dark">
                Understanding JavaScript Prototypes
              </a></h1><p class="PostMeta"><span class="PostMeta-date">
              January, 20 2016
            </span><span class="PostMeta-author">
              by Anthony Koch
            </span></div></header><div><div class="Post-body md" style="animation-delay:.3s"><p>Several months ago, I set out to get a deeper understanding of JavaScript, specifically in the area of prototypes. Prototypes were a fuzzy concept for me. I sort of knew how to use them, but didn't fully understand them. After a lot of study, I've started to see the picture of how prototypes work, and that they are not as complicated as I first thought.</p>
<!-- endexcerpt -->
<h3>What is a prototype?</h3>
<p>Some confusion may arise when talking about prototypes because the word "prototype" may be used to describe the internal <code>[[Prototype]]</code> property of an object, or the <code>prototype</code> property of a function. These are two separate things, but later on we'll see that they relate.</p>
<h4>Internal prototype</h4>
<p>Strings, numbers, booleans, objects, arrays, and functions are created with an internal <code>[[Prototype]]</code> property. The value of this property is an object, whose purpose purpose will be explained later. Since this property is internal, it is not exposed to us through the code we write. However, when the fifth version of EcmaScript came along, the specification did allow the retrieval of this internal property with <code>Object.getPrototypeOf</code>.</p>
<p>Some time later, browsers started implementing a property called  <code>__proto__</code>, which allows both reading and writing of an object's internal <code>[[Prototype]]</code> property. It's important to know that the use of this property is <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto">highly discouraged</a>, and an alternative is explained later on. The <code>__proto__</code> property is only used here in examples as it provides a better illustration.</p>
<p>Also, it's important to remember that both <code>Object.getPrototypeOf</code> and the <code>__proto__</code> property return the internal <code>[[Prototype]]</code> of an object. So, when I say <code>[[Prototype]]</code>, I'm referring to the object returned from <code>Object.getPrototypeOf</code> or <code>__proto__</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> bob = {};
<span class="hljs-keyword">var</span> str = <span class="hljs-string">'Hello'</span>;
<span class="hljs-keyword">var</span> num = <span class="hljs-number">123</span>;

<span class="hljs-comment">// They all have a [[Prototype]], which we can retrieve with __proto__</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> bob.__proto__); <span class="hljs-comment">// 'object'</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> str.__proto__); <span class="hljs-comment">// 'object'</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> num.__proto__); <span class="hljs-comment">// 'object'</span>

<span class="hljs-comment">// we can also retrieve it with Object.getPrototypeOf</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(bob) === bob.__proto__); <span class="hljs-comment">// true</span>
</code></pre>
<h4>Function prototype</h4>
<p>Functions are created with a property called <code>prototype</code>, whose value is an object. Most people have probably found themselves using this property at some point. It is a common pattern to assign what are commonly called "methods", which are functions, or other values to this object, and then use the function as constructor, meaning the function is called with <code>new</code>. When the function is called with <code>new</code>, an object is returned that inherits the properties of the constructor's <code>prototype</code> object. This is called the "constructor" pattern.</p>
<pre class="hljs"><code><span class="hljs-comment">// Person is the constructor</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>{

}

<span class="hljs-comment">// The prototype property is a normal object</span>
<span class="hljs-built_in">console</span>.log(Person.prototype); <span class="hljs-comment">// {}</span>

Person.prototype.eatFood = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'scrumptious!'</span>);
};

<span class="hljs-keyword">var</span> bob = <span class="hljs-keyword">new</span> Person();

<span class="hljs-comment">// bob is an object that "inherits" the eatFood function</span>
bob.eatFood(); <span class="hljs-comment">// 'scrumptious!'</span>
</code></pre>
<p>The <code>eatFood</code> function was assigned to the <code>Person.prototype</code> object, but we can access it on <code>bob</code>. So, why does assigning values to the <code>prototype</code> object allow us to then access those values on objects returned from the constructor? Well, there are two parts to this:</p>
<ol>
<li>What happens in the constructor when the object is created.</li>
<li>How properties are resolved.</li>
</ol>
<h3>Constructor functions</h3>
<p>A constructor, according to the EcmaScript <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15">spec</a>, is a function that is meant for use with the <code>new</code> operator. There's nothing special about them; they're just functions. Normally, the name of the function is written in Pascal casing, but this is just a convention programmers use to signify that the function is intended to be used with the <code>new</code> operator.</p>
<p>When you call a function with the <code>new</code> operator, the function runs as it normally would, except the value of <code>this</code> is set to a newly created object, and the object created has its <code>[[Prototype]]</code> set to the <code>prototype</code> object of the constructor. After the code inside the function finishes, the newly created object is returned.</p>
<p>Below is an example of what happens in the background when a function is called with the <code>new</code> operator. The code below wouldn't actually run because assigning a value to <code>this</code> would generate a syntax error, but the code would otherwise run just fine.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-comment">// Set "this" to a new object </span>
	<span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span> = {};
	<span class="hljs-comment">// Set the [[Prototype]] of the object to the constructor's prototype </span>
	<span class="hljs-keyword">this</span>.__proto__ = Person.prototype;

	<span class="hljs-comment">// The code defined in the function would run at this point</span>

	<span class="hljs-comment">// return the object</span>
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}

Person.prototype.eatFood = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'scrumptious!'</span>);
};

<span class="hljs-keyword">var</span> bob = <span class="hljs-keyword">new</span> Person();
bob.eatFood(); <span class="hljs-comment">// 'scrumptious!'</span>

<span class="hljs-comment">// Bob's [[Prototype]] is Person.prototyope</span>
<span class="hljs-built_in">console</span>.log(bob.__proto__ === Person.prototype); <span class="hljs-comment">// true</span>
</code></pre>
<p><strong>Note:</strong> You can find this process in the ES5 spec <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-13.2.2">here</a>.</p>
<p>This setting of the newly created object's <code>[[Prototype]]</code> to its constructor's <code>protototype</code> object is the same thing that happens for strings, numbers, booleans, objects, arrays, and functions. They all have their <code>[[Prototype]]</code> set to the <code>prototype</code> property of their associated constructor.</p>
<pre class="hljs"><code><span class="hljs-comment">// An object's [[Prototype]] is Object.prototype</span>
<span class="hljs-built_in">console</span>.log({}.__proto__ === <span class="hljs-built_in">Object</span>.prototype); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// An array's [[Prototype]] is Array.prototype </span>
<span class="hljs-built_in">console</span>.log([].__proto__ === <span class="hljs-built_in">Array</span>.prototype); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// A string's [[Prototype]] is String.prototype </span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello'</span>.__proto__ === <span class="hljs-built_in">String</span>.prototype); <span class="hljs-comment">// true</span>
</code></pre>
<p>This is how the <code>[[Prototype]]</code> of an object relates to the <code>prototype</code> of its constructor, they're the same object. Although this is true, this doesn't explain how we can set the function <code>eatFood</code> on <code>Person.prototype</code>, and be able to call it on <code>bob</code>. This brings in the second part, which is property lookup.</p>
<h3>Property lookup</h3>
<p>When a property isn't found on the object in question, the property lookup goes from the object to its <code>[[Prototype]]</code> object. From the earlier example of the <code>Person</code> constructor, we can see that the constructor sets <code>bob</code>'s <code>[[Prototype]]</code> to its <code>prototype</code> object. Therefore, when accessing a property on <code>bob</code> that <code>bob</code> doesn't have, the property lookup will go to the <code>Person.prototype</code> object.</p>
<p>If the <code>Person.prototype</code> object didn't have the property, the property lookup would go to the <code>[[Prototype]]</code> of the <code>Person.prototype</code> object, which would be <code>Object.prototype</code>. If <code>Object.prototype</code> didn't have the property we would check its <code>[[Prototype]]</code>. However, <code>Object.prototype</code> has its <code>[[Prototype]]</code> explicitly set to null, the purpose being that the property lookup is supposed to end there, since the spec says when a <code>[[Prototype]]</code> that is null is reached, the property lookup ends and <code>undefined</code> should be returned in place of the property's value.</p>
<p><strong>Note:</strong> If you're interested, you can read about the property lookup operations in the ES5 spec <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-8.12.2">here</a>.</p>
<pre class="hljs"><code>The prototype chain <span class="hljs-keyword">of</span> bob 

             Person.prototype               <span class="hljs-built_in">Object</span>.prototype
                   |                              |
bob   ->   bob.__proto__   ->   bob.__proto__.__proto__
</code></pre>
<p>So, the purpose of the <code>[[Prototype]]</code> is as a delegate for property lookup in the case the original object doesn't have the property. In essence, it's another place to look for the properties of an object.</p>
<p>An important thing to realize here is that the property lookup doesn't go from the object, to its constructor, and then to the constructor's <code>prototype</code> object. The property lookup goes from the object to whatever is set as its <code>[[Prototype]]</code>. We could at anytime change the value of <code>Person</code>'s <code>prototype</code> property to something else, and <code>bob</code>'s <code>[[Prototype]]</code> would still point to the constructor's original <code>prototype</code> object, because that's what <code>bob</code> was initialized with.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>{}
<span class="hljs-keyword">var</span> originalPrototype = Person.prototype;

<span class="hljs-comment">// Bob has its linking to the original prototype</span>
<span class="hljs-keyword">var</span> bob = <span class="hljs-keyword">new</span> Person();

Person.prototype = {};

<span class="hljs-comment">// Bob doesn't link to Person's new prototype</span>
<span class="hljs-built_in">console</span>.log(bob.__proto__ === Person.prototype);  <span class="hljs-comment">// false</span>

<span class="hljs-comment">// Bob's `[[Prototype]]` is still the original Person.prototype object</span>
<span class="hljs-built_in">console</span>.log(bob.__proto__ === originalPrototype); <span class="hljs-comment">// true</span>
</code></pre>
<p>This is why you'll hear sayings such as "objects link to other objects". Objects are directly linked together through their <code>[[Prototype]]</code>, meaning the constructor is actually extraneous. <code>bob</code> links directly to another object, that object being <code>Person.prototype</code>, and <code>Person.prototype</code> links directly to another object, that object being <code>Object.prototype</code>.</p>
<p>Now, knowing how property lookup works, we should be able to see this property lookup delegation at work if we were to put a property on <code>Object.prototype</code>. Since mostly all objects have a prototype chain that leads back to <code>Object.prototype</code>, we should be to access it on to strings, numbers, objects, arrays, etc.</p>
<pre class="hljs"><code><span class="hljs-built_in">Object</span>.prototype.coolStuff = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Really cool'</span>);
};

({}).coolStuff();     <span class="hljs-comment">// 'really cool'</span>
[].coolStuff();       <span class="hljs-comment">// 'really cool'</span>
<span class="hljs-string">''</span>.coolStuff();       <span class="hljs-comment">// 'really cool'</span>
(<span class="hljs-number">123</span>).coolStuff();    <span class="hljs-comment">// 'really cool'</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eatFood</span>(<span class="hljs-params"></span>) </span>{}
eatFood.coolStuff();  <span class="hljs-comment">// 'really cool'</span>

<span class="hljs-built_in">Object</span>.prototype.coolStuff.coolStuff(); <span class="hljs-comment">// 'really cool'</span>
</code></pre>
<p>The last one, where we call <code>coolStuff</code> as a property of itself, works because <code>coolStuff</code> has its <code>[[Prototype]]</code> set to <code>Function.prototype</code>. Since <code>Function.prototype</code> doesn't have a property with the name of <code>coolStuff</code>, the property lookup goes to the <code>[[Prototype]]</code> of <code>Function.prototype</code>, which is <code>Object.prototype</code>. Since <code>Object.prototype</code> has a property named <code>coolStuff</code>, the value for the property is returned.</p>
<pre><code>The prototype chain of coolStuff

      Function.prototype                     Object.prototype 
              |                                    |
coolStuff.__proto__   ->   coolStuff.__proto__.__proto__
</code></pre>
<p>As another fun example, we'll set a property on <code>Object.prototype</code> that has a  number as the key, and then access the same key on an array.</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> arr = [];
<span class="hljs-built_in">Object</span>.prototype[<span class="hljs-number">0</span>] = <span class="hljs-string">'tomatoes'</span>;
<span class="hljs-built_in">console</span>.log(arr[<span class="hljs-number">0</span>]);

<span class="hljs-keyword">var</span> names = [<span class="hljs-string">'John'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Jim'</span>];
<span class="hljs-built_in">console</span>.log(names[<span class="hljs-number">0</span>]);
</code></pre>
<p>What do you think will be logged to the console with <code>arr[0]</code>? If your answer is <code>tomatoes</code>, you'd be correct! Array indices are properties, and resolve in the same way properties do. The property lookup goes from the array, to <code>Array.prototype</code>, and then to <code>Object.prototype</code>.</p>
<p>What do you think will be logged to the console with <code>names[0]</code>? If you guessed <code>John</code>, you'd also be correct. Since the <code>names</code> array has a property with the name of <code>0</code>, there is no need to check the prototype chain.</p>
<h3>Prototypes without constructors</h3>
<p>The examples before show objects having a <code>[[Prototype]]</code> such as <code>String.prototype</code> and <code>Person.prototype</code>, where <code>String</code> and <code>Person</code> are constructor functions. But, as was mentioned before, constructors are extraneous and aren't actually necessary for inheritance to take place. The only parts necessary are two objects, and all we have to do is set one object as the <code>[[Prototype]]</code> of the other object.</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> bob = {};
<span class="hljs-keyword">var</span> person = {
	<span class="hljs-attr">eatFood</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
		<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'scrumptious!'</span>);
	}
};

<span class="hljs-comment">// Sets person as the [[Prototype]] of bob</span>
bob.__proto__ = person;

<span class="hljs-comment">// bob can still eat his food</span>
bob.eatFood(); <span class="hljs-comment">// 'scrumptious!'</span>
</code></pre>
<p>In the above example, <code>person</code> is set as the <code>[[Prototype]]</code> of <code>bob</code>, meaning <code>bob</code> will now delegate property access to <code>person</code> when <code>bob</code> itself doesn't have the property.</p>
<p><strong>Note:</strong> Although this would produce the intended result, assigning to the <code>__proto__</code> property in this way is <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto">highly discouraged</a>. The safe way to set the <code>[[Prototype]]</code> of an object is with <code>Object.create</code>.</p>
<h4>Object.create</h4>
<p><code>Object.create</code> is a function that simply creates an object and sets the object's <code>[[Prototype]]</code> to what is passed as the first argument. It also allows defining new properties on the object, but we won't focus on that here.</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> person = {
	<span class="hljs-attr">eatFood</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
		<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'scrumptious!'</span>);
	}
};

<span class="hljs-keyword">var</span> bob = <span class="hljs-built_in">Object</span>.create(person);

<span class="hljs-comment">// Bob's [[Prototype]] is set to person</span>
<span class="hljs-built_in">console</span>.log(bob.__proto__ === person); <span class="hljs-comment">// true </span>
bob.eatFood(); <span class="hljs-comment">// 'scrumptious!'</span>
</code></pre>
<p>With this comes the prototypal design pattern. Some may say this pattern "creates objects from other objects", but in my opinion, this isn't really accurate, since what's happening is we're just creating a new, arbitrary object, and settings its <code>[[Prototype]]</code> to another object. There isn't really a creation from another object. There isn't a copying of another object. There's just an object, which delegates property lookup to its <code>[[Prototype]]</code> object, and so on through its prototype chain.</p>
<pre class="hljs"><code><span class="hljs-comment">// The functionality representing a person</span>
<span class="hljs-keyword">var</span> person = {
	<span class="hljs-attr">eatFood</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
		<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'scrumptious!'</span>);
	}
};

<span class="hljs-comment">// The functionality representing a salesman</span>
<span class="hljs-keyword">var</span> salesman = <span class="hljs-built_in">Object</span>.create(person);
<span class="hljs-comment">// We then extend salesman to have the functionality it needs</span>
salesman.sellThings = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'I am selling things'</span>);
}

<span class="hljs-comment">// We can then create objects that have the functionality of a person and salesman</span>
<span class="hljs-keyword">var</span> bob = <span class="hljs-built_in">Object</span>.create(salesman);
bob.sellThings(); <span class="hljs-comment">// 'I am selling things'</span>
bob.eatFood(); <span class="hljs-comment">// 'scrumptious!'</span>

<span class="hljs-comment">// We can then set properties onto bob as needed</span>
bob.firstName = <span class="hljs-string">'bob'</span>;

<span class="hljs-comment">// The prototype chain of bob looks like this:</span>

     salesman   person  <span class="hljs-built_in">Object</span>.prototype
        |         |          |
bob.__proto__.__proto__.__proto__
</code></pre>
<h4>Comparing Object.create and constructors</h4>
<p>If we compare the simplified illustration of what happens in the background of a constructor call and a simplified version of <code>Object.create</code>, we would see some similarities.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-comment">// Create a new object </span>
	<span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span> = {};
	<span class="hljs-comment">// Set the object's [[Prototype]]</span>
	<span class="hljs-keyword">this</span>.__proto__ = Person.prototype;

	<span class="hljs-comment">// The code in the function would run at this point</span>

	<span class="hljs-comment">// Return the object</span>
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}

<span class="hljs-built_in">Object</span>.create = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prototype</span>) </span>{
	<span class="hljs-comment">// Create a new object </span>
	<span class="hljs-keyword">var</span> obj = {};
	<span class="hljs-comment">// Set the object's [[Prototype]]</span>
	obj.__proto__ = prototype;

	<span class="hljs-comment">// Return the object</span>
	<span class="hljs-keyword">return</span> obj;
};
</code></pre>
<p>They both create a new object, and then set the <code>[[Prototype]]</code> of the new object to another object, which sets up the environment to allow property delegation to work. So, constructors are more like factories, returning objects pre-linked to another object, and the linking just happens to be to the constructor's <code>prototype</code> object.</p>
<p>Now, you may say, "That's not the Object.create polyfill I've seen elsewhere!". That's true, it's not. If we were to look at a polyfill for <code>Object.create</code> we would see the following.</p>
<pre class="hljs"><code><span class="hljs-built_in">Object</span>.create = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">proto, properties</span>) </span>{
	<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> proto !== <span class="hljs-string">'object'</span> && <span class="hljs-keyword">typeof</span> proto !== <span class="hljs-literal">null</span>) {
		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Object prototype may only be an Object or null'</span>);
	}

	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Temp</span>(<span class="hljs-params"></span>) </span>{}
	Temp.prototype = proto;

	<span class="hljs-comment">// Create the new object </span>
	<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> Temp();

	ObjectDefineProperties(obj, properties);

	<span class="hljs-keyword">return</span> obj;
};
</code></pre>
<p>The reason why a constructor is used in the actual polyfill instead of <code>__proto__</code> is because assigning to <code>__proto__</code> brings performance hits, and may not entirely be cross browser. The only way to create an object with a specific <code>[[Prototype]]</code> in older browsers is with a constructor function.</p>
<p>If we look at the definition of <code>Object.create</code> in NodeJS, we would see that it doesn't use a constructor function (code obtained from the <a href="https://github.com/nodejs/node/blob/db9e122182f7e605eba2eb2e9ddea0bf00bb572c/deps/v8/src/js/v8natives.js#L1017">NodeJS github repository</a>).</p>
<pre class="hljs"><code><span class="hljs-comment">// ES5 section 15.2.3.5.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ObjectCreate</span>(<span class="hljs-params">proto, properties</span>) </span>{
  <span class="hljs-keyword">if</span> (!IS_SPEC_OBJECT(proto) && proto !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> MakeTypeError(kProtoObjectOrNull, proto);
  }
  <span class="hljs-keyword">var</span> obj = {};
  %InternalSetPrototype(obj, proto);
  <span class="hljs-keyword">if</span> (!IS_UNDEFINED(properties)) ObjectDefineProperties(obj, properties);
  <span class="hljs-keyword">return</span> obj;
}
</code></pre>
<p>There's no constructor function here. It literally just creates a new, empty object, and sets the newly created object's <code>[[Prototype]]</code> with some sort of internal function.</p>
<h4>Creating objects without prototypes</h4>
<p>When <code>Object.create</code> is passed <code>null</code>, the object returned will have no object set as its <code>[[Prototype]]</code>. I have yet to find a use case for this, but it's interesting nonetheless.</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> bob = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(bob)); <span class="hljs-comment">// null</span>

bob.toString(); <span class="hljs-comment">// TypeError: bob.toString is not a function</span>
</code></pre>
<p>If we try to call the <code>toString</code> property of <code>bob</code>, we'll get a TypeError saying "bob.toString is not a function". This is because the <code>toString</code> property is defined on <code>Object.prototype</code>, but since <code>bob</code> has a <code>[[Prototype]]</code> that is <code>null</code>, the property lookup has nowhere to go, which means it can't reach <code>Object.prototype</code>. As a result, the property lookup returns <code>undefined</code>, which of course is not callable, hence "bob.toString is not a function".</p>
<h3>Constructors, classes, and prototypal patterns</h3>
<p>It doesn't matter which pattern you choose, whether it be the constructor pattern, classes, the prototypal pattern, or any other pattern that claims "inheritance" in JavaScript. They <strong>all</strong> use the same underlying mechanism, which is the delegation of property lookup through an object's prototype chain.</p>
<h3>Primitive prototypes</h3>
<p>I have referred to strings, numbers, and booleans as objects, and that we can access properties on them, but this is not technically true. Strings, numbers, and booleans are primitives, and they themselves don't have properties. When accessing a property on a value that is a primitive, the JS engine wraps the primitive in an object wrapper. For example, a number would be wrapped in a Number object wrapper, and a string would be wrapped in a String object wrapper. This process is called "boxing and unboxing".</p>
<p>So, when I call numbers, strings, and booleans objects, I'm referring to their object wrappers. The wrappers are the ones that we are accessing properties on, not the primitive itself.</p>
<p><strong>Note:</strong> The function that wraps primitives in their object wrappers can be found <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-9.9">here</a>.</p>
<pre class="hljs"><code><span class="hljs-comment">// so this</span>
<span class="hljs-string">'hello'</span>.__proto__
<span class="hljs-comment">// is turned into this by the JS engine automatically</span>
<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">'hello'</span>).__proto__

<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">'hello'</span>)); 
<span class="hljs-comment">// {</span>
<span class="hljs-comment">// 	0: "h", </span>
<span class="hljs-comment">//  1: "e", </span>
<span class="hljs-comment">//  2: "l", </span>
<span class="hljs-comment">//  3: "l", </span>
<span class="hljs-comment">//  4: "o", </span>
<span class="hljs-comment">// 	length: 5,</span>
<span class="hljs-comment">// 	[[PrimitiveValue]]: "hello"</span>
<span class="hljs-comment">// }</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">10</span>)); <span class="hljs-comment">// { [[PrimitiveValue]]: 12 }</span>
</code></pre>
<h3>Conclusion</h3>
<p>Prototypes don't have to be magic. Once you learn how they work, it will explain a lot of the patterns that are out there. If you still don't understand how prototypes after reading this, that's normal. It took me a while before I finally understood them. Once you learn them though, you'll realize the concept is actually really simple! Keep on learning and you'll get them down!</p>
<h3>Further Reading</h3>
<p><a href="http://stackoverflow.com/questions/23807805/why-is-mutating-the-prototype-of-an-object-bad-for-performance">Why is mutating __proto__ bad</a></p>
</div></div></div></article></div><!----></div></div></div></div></div><script type="text/javascript">window.__NUXT__={layout:"default",data:[{post:{excerpt:{content:"<p>Several months ago, I set out to get a deeper understanding of JavaScript, specifically in the area of prototypes. Prototypes were a fuzzy concept for me. I sort of knew how to use them, but didn't fully understand them. After a lot of study, I've started to see the picture of how prototypes work, and that they are not as complicated as I first thought.</p>\n",loc:{start:0,end:358}},layout:"post",author:"Anthony Koch",title:"Understanding JavaScript Prototypes",tags:["JavaScript","prototypes"],id:6,created_at:"2016-01-21T00:00:00.000Z",humanized:{created_at:"January, 20 2016"},url:"/blog/understanding-javascript-prototypes",slug:"understanding-javascript-prototypes",next:null,previous:{url:"/blog/medium-style-images",layout:"post",author:"Anthony Koch",title:"Medium style image loading",tags:["stackblur","medium","lazy loading"],id:5,created_at:"2016-01-07T00:00:00.000Z"},contents:'<p>Several months ago, I set out to get a deeper understanding of JavaScript, specifically in the area of prototypes. Prototypes were a fuzzy concept for me. I sort of knew how to use them, but didn\'t fully understand them. After a lot of study, I\'ve started to see the picture of how prototypes work, and that they are not as complicated as I first thought.</p>\n\x3c!-- endexcerpt --\x3e\n<h3>What is a prototype?</h3>\n<p>Some confusion may arise when talking about prototypes because the word &quot;prototype&quot; may be used to describe the internal <code>[[Prototype]]</code> property of an object, or the <code>prototype</code> property of a function. These are two separate things, but later on we\'ll see that they relate.</p>\n<h4>Internal prototype</h4>\n<p>Strings, numbers, booleans, objects, arrays, and functions are created with an internal <code>[[Prototype]]</code> property. The value of this property is an object, whose purpose purpose will be explained later. Since this property is internal, it is not exposed to us through the code we write. However, when the fifth version of EcmaScript came along, the specification did allow the retrieval of this internal property with <code>Object.getPrototypeOf</code>.</p>\n<p>Some time later, browsers started implementing a property called  <code>__proto__</code>, which allows both reading and writing of an object\'s internal <code>[[Prototype]]</code> property. It\'s important to know that the use of this property is <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto">highly discouraged</a>, and an alternative is explained later on. The <code>__proto__</code> property is only used here in examples as it provides a better illustration.</p>\n<p>Also, it\'s important to remember that both <code>Object.getPrototypeOf</code> and the <code>__proto__</code> property return the internal <code>[[Prototype]]</code> of an object. So, when I say <code>[[Prototype]]</code>, I\'m referring to the object returned from <code>Object.getPrototypeOf</code> or <code>__proto__</code>.</p>\n<pre class="hljs"><code><span class="hljs-keyword">var</span> bob = {};\n<span class="hljs-keyword">var</span> str = <span class="hljs-string">\'Hello\'</span>;\n<span class="hljs-keyword">var</span> num = <span class="hljs-number">123</span>;\n\n<span class="hljs-comment">// They all have a [[Prototype]], which we can retrieve with __proto__</span>\n<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> bob.__proto__); <span class="hljs-comment">// \'object\'</span>\n<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> str.__proto__); <span class="hljs-comment">// \'object\'</span>\n<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> num.__proto__); <span class="hljs-comment">// \'object\'</span>\n\n<span class="hljs-comment">// we can also retrieve it with Object.getPrototypeOf</span>\n<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(bob) === bob.__proto__); <span class="hljs-comment">// true</span>\n</code></pre>\n<h4>Function prototype</h4>\n<p>Functions are created with a property called <code>prototype</code>, whose value is an object. Most people have probably found themselves using this property at some point. It is a common pattern to assign what are commonly called &quot;methods&quot;, which are functions, or other values to this object, and then use the function as constructor, meaning the function is called with <code>new</code>. When the function is called with <code>new</code>, an object is returned that inherits the properties of the constructor\'s <code>prototype</code> object. This is called the &quot;constructor&quot; pattern.</p>\n<pre class="hljs"><code><span class="hljs-comment">// Person is the constructor</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>{\n\n}\n\n<span class="hljs-comment">// The prototype property is a normal object</span>\n<span class="hljs-built_in">console</span>.log(Person.prototype); <span class="hljs-comment">// {}</span>\n\nPerson.prototype.eatFood = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'scrumptious!\'</span>);\n};\n\n<span class="hljs-keyword">var</span> bob = <span class="hljs-keyword">new</span> Person();\n\n<span class="hljs-comment">// bob is an object that "inherits" the eatFood function</span>\nbob.eatFood(); <span class="hljs-comment">// \'scrumptious!\'</span>\n</code></pre>\n<p>The <code>eatFood</code> function was assigned to the <code>Person.prototype</code> object, but we can access it on <code>bob</code>. So, why does assigning values to the <code>prototype</code> object allow us to then access those values on objects returned from the constructor? Well, there are two parts to this:</p>\n<ol>\n<li>What happens in the constructor when the object is created.</li>\n<li>How properties are resolved.</li>\n</ol>\n<h3>Constructor functions</h3>\n<p>A constructor, according to the EcmaScript <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15">spec</a>, is a function that is meant for use with the <code>new</code> operator. There\'s nothing special about them; they\'re just functions. Normally, the name of the function is written in Pascal casing, but this is just a convention programmers use to signify that the function is intended to be used with the <code>new</code> operator.</p>\n<p>When you call a function with the <code>new</code> operator, the function runs as it normally would, except the value of <code>this</code> is set to a newly created object, and the object created has its <code>[[Prototype]]</code> set to the <code>prototype</code> object of the constructor. After the code inside the function finishes, the newly created object is returned.</p>\n<p>Below is an example of what happens in the background when a function is called with the <code>new</code> operator. The code below wouldn\'t actually run because assigning a value to <code>this</code> would generate a syntax error, but the code would otherwise run just fine.</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-comment">// Set "this" to a new object </span>\n\t<span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span> = {};\n\t<span class="hljs-comment">// Set the [[Prototype]] of the object to the constructor\'s prototype </span>\n\t<span class="hljs-keyword">this</span>.__proto__ = Person.prototype;\n\n\t<span class="hljs-comment">// The code defined in the function would run at this point</span>\n\n\t<span class="hljs-comment">// return the object</span>\n\t<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;\n}\n\nPerson.prototype.eatFood = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'scrumptious!\'</span>);\n};\n\n<span class="hljs-keyword">var</span> bob = <span class="hljs-keyword">new</span> Person();\nbob.eatFood(); <span class="hljs-comment">// \'scrumptious!\'</span>\n\n<span class="hljs-comment">// Bob\'s [[Prototype]] is Person.prototyope</span>\n<span class="hljs-built_in">console</span>.log(bob.__proto__ === Person.prototype); <span class="hljs-comment">// true</span>\n</code></pre>\n<p><strong>Note:</strong> You can find this process in the ES5 spec <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-13.2.2">here</a>.</p>\n<p>This setting of the newly created object\'s <code>[[Prototype]]</code> to its constructor\'s <code>protototype</code> object is the same thing that happens for strings, numbers, booleans, objects, arrays, and functions. They all have their <code>[[Prototype]]</code> set to the <code>prototype</code> property of their associated constructor.</p>\n<pre class="hljs"><code><span class="hljs-comment">// An object\'s [[Prototype]] is Object.prototype</span>\n<span class="hljs-built_in">console</span>.log({}.__proto__ === <span class="hljs-built_in">Object</span>.prototype); <span class="hljs-comment">// true</span>\n\n<span class="hljs-comment">// An array\'s [[Prototype]] is Array.prototype </span>\n<span class="hljs-built_in">console</span>.log([].__proto__ === <span class="hljs-built_in">Array</span>.prototype); <span class="hljs-comment">// true</span>\n\n<span class="hljs-comment">// A string\'s [[Prototype]] is String.prototype </span>\n<span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'Hello\'</span>.__proto__ === <span class="hljs-built_in">String</span>.prototype); <span class="hljs-comment">// true</span>\n</code></pre>\n<p>This is how the <code>[[Prototype]]</code> of an object relates to the <code>prototype</code> of its constructor, they\'re the same object. Although this is true, this doesn\'t explain how we can set the function <code>eatFood</code> on <code>Person.prototype</code>, and be able to call it on <code>bob</code>. This brings in the second part, which is property lookup.</p>\n<h3>Property lookup</h3>\n<p>When a property isn\'t found on the object in question, the property lookup goes from the object to its <code>[[Prototype]]</code> object. From the earlier example of the <code>Person</code> constructor, we can see that the constructor sets <code>bob</code>\'s <code>[[Prototype]]</code> to its <code>prototype</code> object. Therefore, when accessing a property on <code>bob</code> that <code>bob</code> doesn\'t have, the property lookup will go to the <code>Person.prototype</code> object.</p>\n<p>If the <code>Person.prototype</code> object didn\'t have the property, the property lookup would go to the <code>[[Prototype]]</code> of the <code>Person.prototype</code> object, which would be <code>Object.prototype</code>. If <code>Object.prototype</code> didn\'t have the property we would check its <code>[[Prototype]]</code>. However, <code>Object.prototype</code> has its <code>[[Prototype]]</code> explicitly set to null, the purpose being that the property lookup is supposed to end there, since the spec says when a <code>[[Prototype]]</code> that is null is reached, the property lookup ends and <code>undefined</code> should be returned in place of the property\'s value.</p>\n<p><strong>Note:</strong> If you\'re interested, you can read about the property lookup operations in the ES5 spec <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-8.12.2">here</a>.</p>\n<pre class="hljs"><code>The prototype chain <span class="hljs-keyword">of</span> bob \n\n             Person.prototype               <span class="hljs-built_in">Object</span>.prototype\n                   |                              |\nbob   -&gt;   bob.__proto__   -&gt;   bob.__proto__.__proto__\n</code></pre>\n<p>So, the purpose of the <code>[[Prototype]]</code> is as a delegate for property lookup in the case the original object doesn\'t have the property. In essence, it\'s another place to look for the properties of an object.</p>\n<p>An important thing to realize here is that the property lookup doesn\'t go from the object, to its constructor, and then to the constructor\'s <code>prototype</code> object. The property lookup goes from the object to whatever is set as its <code>[[Prototype]]</code>. We could at anytime change the value of <code>Person</code>\'s <code>prototype</code> property to something else, and <code>bob</code>\'s <code>[[Prototype]]</code> would still point to the constructor\'s original <code>prototype</code> object, because that\'s what <code>bob</code> was initialized with.</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>{}\n<span class="hljs-keyword">var</span> originalPrototype = Person.prototype;\n\n<span class="hljs-comment">// Bob has its linking to the original prototype</span>\n<span class="hljs-keyword">var</span> bob = <span class="hljs-keyword">new</span> Person();\n\nPerson.prototype = {};\n\n<span class="hljs-comment">// Bob doesn\'t link to Person\'s new prototype</span>\n<span class="hljs-built_in">console</span>.log(bob.__proto__ === Person.prototype);  <span class="hljs-comment">// false</span>\n\n<span class="hljs-comment">// Bob\'s `[[Prototype]]` is still the original Person.prototype object</span>\n<span class="hljs-built_in">console</span>.log(bob.__proto__ === originalPrototype); <span class="hljs-comment">// true</span>\n</code></pre>\n<p>This is why you\'ll hear sayings such as &quot;objects link to other objects&quot;. Objects are directly linked together through their <code>[[Prototype]]</code>, meaning the constructor is actually extraneous. <code>bob</code> links directly to another object, that object being <code>Person.prototype</code>, and <code>Person.prototype</code> links directly to another object, that object being <code>Object.prototype</code>.</p>\n<p>Now, knowing how property lookup works, we should be able to see this property lookup delegation at work if we were to put a property on <code>Object.prototype</code>. Since mostly all objects have a prototype chain that leads back to <code>Object.prototype</code>, we should be to access it on to strings, numbers, objects, arrays, etc.</p>\n<pre class="hljs"><code><span class="hljs-built_in">Object</span>.prototype.coolStuff = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'Really cool\'</span>);\n};\n\n({}).coolStuff();     <span class="hljs-comment">// \'really cool\'</span>\n[].coolStuff();       <span class="hljs-comment">// \'really cool\'</span>\n<span class="hljs-string">\'\'</span>.coolStuff();       <span class="hljs-comment">// \'really cool\'</span>\n(<span class="hljs-number">123</span>).coolStuff();    <span class="hljs-comment">// \'really cool\'</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eatFood</span>(<span class="hljs-params"></span>) </span>{}\neatFood.coolStuff();  <span class="hljs-comment">// \'really cool\'</span>\n\n<span class="hljs-built_in">Object</span>.prototype.coolStuff.coolStuff(); <span class="hljs-comment">// \'really cool\'</span>\n</code></pre>\n<p>The last one, where we call <code>coolStuff</code> as a property of itself, works because <code>coolStuff</code> has its <code>[[Prototype]]</code> set to <code>Function.prototype</code>. Since <code>Function.prototype</code> doesn\'t have a property with the name of <code>coolStuff</code>, the property lookup goes to the <code>[[Prototype]]</code> of <code>Function.prototype</code>, which is <code>Object.prototype</code>. Since <code>Object.prototype</code> has a property named <code>coolStuff</code>, the value for the property is returned.</p>\n<pre><code>The prototype chain of coolStuff\n\n      Function.prototype                     Object.prototype \n              |                                    |\ncoolStuff.__proto__   -&gt;   coolStuff.__proto__.__proto__\n</code></pre>\n<p>As another fun example, we\'ll set a property on <code>Object.prototype</code> that has a  number as the key, and then access the same key on an array.</p>\n<pre class="hljs"><code><span class="hljs-keyword">var</span> arr = [];\n<span class="hljs-built_in">Object</span>.prototype[<span class="hljs-number">0</span>] = <span class="hljs-string">\'tomatoes\'</span>;\n<span class="hljs-built_in">console</span>.log(arr[<span class="hljs-number">0</span>]);\n\n<span class="hljs-keyword">var</span> names = [<span class="hljs-string">\'John\'</span>, <span class="hljs-string">\'Bob\'</span>, <span class="hljs-string">\'Jim\'</span>];\n<span class="hljs-built_in">console</span>.log(names[<span class="hljs-number">0</span>]);\n</code></pre>\n<p>What do you think will be logged to the console with <code>arr[0]</code>? If your answer is <code>tomatoes</code>, you\'d be correct! Array indices are properties, and resolve in the same way properties do. The property lookup goes from the array, to <code>Array.prototype</code>, and then to <code>Object.prototype</code>.</p>\n<p>What do you think will be logged to the console with <code>names[0]</code>? If you guessed <code>John</code>, you\'d also be correct. Since the <code>names</code> array has a property with the name of <code>0</code>, there is no need to check the prototype chain.</p>\n<h3>Prototypes without constructors</h3>\n<p>The examples before show objects having a <code>[[Prototype]]</code> such as <code>String.prototype</code> and <code>Person.prototype</code>, where <code>String</code> and <code>Person</code> are constructor functions. But, as was mentioned before, constructors are extraneous and aren\'t actually necessary for inheritance to take place. The only parts necessary are two objects, and all we have to do is set one object as the <code>[[Prototype]]</code> of the other object.</p>\n<pre class="hljs"><code><span class="hljs-keyword">var</span> bob = {};\n<span class="hljs-keyword">var</span> person = {\n\t<span class="hljs-attr">eatFood</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'scrumptious!\'</span>);\n\t}\n};\n\n<span class="hljs-comment">// Sets person as the [[Prototype]] of bob</span>\nbob.__proto__ = person;\n\n<span class="hljs-comment">// bob can still eat his food</span>\nbob.eatFood(); <span class="hljs-comment">// \'scrumptious!\'</span>\n</code></pre>\n<p>In the above example, <code>person</code> is set as the <code>[[Prototype]]</code> of <code>bob</code>, meaning <code>bob</code> will now delegate property access to <code>person</code> when <code>bob</code> itself doesn\'t have the property.</p>\n<p><strong>Note:</strong> Although this would produce the intended result, assigning to the <code>__proto__</code> property in this way is <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto">highly discouraged</a>. The safe way to set the <code>[[Prototype]]</code> of an object is with <code>Object.create</code>.</p>\n<h4>Object.create</h4>\n<p><code>Object.create</code> is a function that simply creates an object and sets the object\'s <code>[[Prototype]]</code> to what is passed as the first argument. It also allows defining new properties on the object, but we won\'t focus on that here.</p>\n<pre class="hljs"><code><span class="hljs-keyword">var</span> person = {\n\t<span class="hljs-attr">eatFood</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'scrumptious!\'</span>);\n\t}\n};\n\n<span class="hljs-keyword">var</span> bob = <span class="hljs-built_in">Object</span>.create(person);\n\n<span class="hljs-comment">// Bob\'s [[Prototype]] is set to person</span>\n<span class="hljs-built_in">console</span>.log(bob.__proto__ === person); <span class="hljs-comment">// true </span>\nbob.eatFood(); <span class="hljs-comment">// \'scrumptious!\'</span>\n</code></pre>\n<p>With this comes the prototypal design pattern. Some may say this pattern &quot;creates objects from other objects&quot;, but in my opinion, this isn\'t really accurate, since what\'s happening is we\'re just creating a new, arbitrary object, and settings its <code>[[Prototype]]</code> to another object. There isn\'t really a creation from another object. There isn\'t a copying of another object. There\'s just an object, which delegates property lookup to its <code>[[Prototype]]</code> object, and so on through its prototype chain.</p>\n<pre class="hljs"><code><span class="hljs-comment">// The functionality representing a person</span>\n<span class="hljs-keyword">var</span> person = {\n\t<span class="hljs-attr">eatFood</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n\t\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'scrumptious!\'</span>);\n\t}\n};\n\n<span class="hljs-comment">// The functionality representing a salesman</span>\n<span class="hljs-keyword">var</span> salesman = <span class="hljs-built_in">Object</span>.create(person);\n<span class="hljs-comment">// We then extend salesman to have the functionality it needs</span>\nsalesman.sellThings = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'I am selling things\'</span>);\n}\n\n<span class="hljs-comment">// We can then create objects that have the functionality of a person and salesman</span>\n<span class="hljs-keyword">var</span> bob = <span class="hljs-built_in">Object</span>.create(salesman);\nbob.sellThings(); <span class="hljs-comment">// \'I am selling things\'</span>\nbob.eatFood(); <span class="hljs-comment">// \'scrumptious!\'</span>\n\n<span class="hljs-comment">// We can then set properties onto bob as needed</span>\nbob.firstName = <span class="hljs-string">\'bob\'</span>;\n\n<span class="hljs-comment">// The prototype chain of bob looks like this:</span>\n\n     salesman   person  <span class="hljs-built_in">Object</span>.prototype\n        |         |          |\nbob.__proto__.__proto__.__proto__\n</code></pre>\n<h4>Comparing Object.create and constructors</h4>\n<p>If we compare the simplified illustration of what happens in the background of a constructor call and a simplified version of <code>Object.create</code>, we would see some similarities.</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-comment">// Create a new object </span>\n\t<span class="hljs-keyword">var</span> <span class="hljs-keyword">this</span> = {};\n\t<span class="hljs-comment">// Set the object\'s [[Prototype]]</span>\n\t<span class="hljs-keyword">this</span>.__proto__ = Person.prototype;\n\n\t<span class="hljs-comment">// The code in the function would run at this point</span>\n\n\t<span class="hljs-comment">// Return the object</span>\n\t<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;\n}\n\n<span class="hljs-built_in">Object</span>.create = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prototype</span>) </span>{\n\t<span class="hljs-comment">// Create a new object </span>\n\t<span class="hljs-keyword">var</span> obj = {};\n\t<span class="hljs-comment">// Set the object\'s [[Prototype]]</span>\n\tobj.__proto__ = prototype;\n\n\t<span class="hljs-comment">// Return the object</span>\n\t<span class="hljs-keyword">return</span> obj;\n};\n</code></pre>\n<p>They both create a new object, and then set the <code>[[Prototype]]</code> of the new object to another object, which sets up the environment to allow property delegation to work. So, constructors are more like factories, returning objects pre-linked to another object, and the linking just happens to be to the constructor\'s <code>prototype</code> object.</p>\n<p>Now, you may say, &quot;That\'s not the Object.create polyfill I\'ve seen elsewhere!&quot;. That\'s true, it\'s not. If we were to look at a polyfill for <code>Object.create</code> we would see the following.</p>\n<pre class="hljs"><code><span class="hljs-built_in">Object</span>.create = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">proto, properties</span>) </span>{\n\t<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> proto !== <span class="hljs-string">\'object\'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> proto !== <span class="hljs-literal">null</span>) {\n\t\t<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">\'Object prototype may only be an Object or null\'</span>);\n\t}\n\n\t<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Temp</span>(<span class="hljs-params"></span>) </span>{}\n\tTemp.prototype = proto;\n\n\t<span class="hljs-comment">// Create the new object </span>\n\t<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> Temp();\n\n\tObjectDefineProperties(obj, properties);\n\n\t<span class="hljs-keyword">return</span> obj;\n};\n</code></pre>\n<p>The reason why a constructor is used in the actual polyfill instead of <code>__proto__</code> is because assigning to <code>__proto__</code> brings performance hits, and may not entirely be cross browser. The only way to create an object with a specific <code>[[Prototype]]</code> in older browsers is with a constructor function.</p>\n<p>If we look at the definition of <code>Object.create</code> in NodeJS, we would see that it doesn\'t use a constructor function (code obtained from the <a href="https://github.com/nodejs/node/blob/db9e122182f7e605eba2eb2e9ddea0bf00bb572c/deps/v8/src/js/v8natives.js#L1017">NodeJS github repository</a>).</p>\n<pre class="hljs"><code><span class="hljs-comment">// ES5 section 15.2.3.5.</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ObjectCreate</span>(<span class="hljs-params">proto, properties</span>) </span>{\n  <span class="hljs-keyword">if</span> (!IS_SPEC_OBJECT(proto) &amp;&amp; proto !== <span class="hljs-literal">null</span>) {\n    <span class="hljs-keyword">throw</span> MakeTypeError(kProtoObjectOrNull, proto);\n  }\n  <span class="hljs-keyword">var</span> obj = {};\n  %InternalSetPrototype(obj, proto);\n  <span class="hljs-keyword">if</span> (!IS_UNDEFINED(properties)) ObjectDefineProperties(obj, properties);\n  <span class="hljs-keyword">return</span> obj;\n}\n</code></pre>\n<p>There\'s no constructor function here. It literally just creates a new, empty object, and sets the newly created object\'s <code>[[Prototype]]</code> with some sort of internal function.</p>\n<h4>Creating objects without prototypes</h4>\n<p>When <code>Object.create</code> is passed <code>null</code>, the object returned will have no object set as its <code>[[Prototype]]</code>. I have yet to find a use case for this, but it\'s interesting nonetheless.</p>\n<pre class="hljs"><code><span class="hljs-keyword">var</span> bob = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);\n<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(bob)); <span class="hljs-comment">// null</span>\n\nbob.toString(); <span class="hljs-comment">// TypeError: bob.toString is not a function</span>\n</code></pre>\n<p>If we try to call the <code>toString</code> property of <code>bob</code>, we\'ll get a TypeError saying &quot;bob.toString is not a function&quot;. This is because the <code>toString</code> property is defined on <code>Object.prototype</code>, but since <code>bob</code> has a <code>[[Prototype]]</code> that is <code>null</code>, the property lookup has nowhere to go, which means it can\'t reach <code>Object.prototype</code>. As a result, the property lookup returns <code>undefined</code>, which of course is not callable, hence &quot;bob.toString is not a function&quot;.</p>\n<h3>Constructors, classes, and prototypal patterns</h3>\n<p>It doesn\'t matter which pattern you choose, whether it be the constructor pattern, classes, the prototypal pattern, or any other pattern that claims &quot;inheritance&quot; in JavaScript. They <strong>all</strong> use the same underlying mechanism, which is the delegation of property lookup through an object\'s prototype chain.</p>\n<h3>Primitive prototypes</h3>\n<p>I have referred to strings, numbers, and booleans as objects, and that we can access properties on them, but this is not technically true. Strings, numbers, and booleans are primitives, and they themselves don\'t have properties. When accessing a property on a value that is a primitive, the JS engine wraps the primitive in an object wrapper. For example, a number would be wrapped in a Number object wrapper, and a string would be wrapped in a String object wrapper. This process is called &quot;boxing and unboxing&quot;.</p>\n<p>So, when I call numbers, strings, and booleans objects, I\'m referring to their object wrappers. The wrappers are the ones that we are accessing properties on, not the primitive itself.</p>\n<p><strong>Note:</strong> The function that wraps primitives in their object wrappers can be found <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-9.9">here</a>.</p>\n<pre class="hljs"><code><span class="hljs-comment">// so this</span>\n<span class="hljs-string">\'hello\'</span>.__proto__\n<span class="hljs-comment">// is turned into this by the JS engine automatically</span>\n<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">\'hello\'</span>).__proto__\n\n<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">\'hello\'</span>)); \n<span class="hljs-comment">// {</span>\n<span class="hljs-comment">// \t0: "h", </span>\n<span class="hljs-comment">//  1: "e", </span>\n<span class="hljs-comment">//  2: "l", </span>\n<span class="hljs-comment">//  3: "l", </span>\n<span class="hljs-comment">//  4: "o", </span>\n<span class="hljs-comment">// \tlength: 5,</span>\n<span class="hljs-comment">// \t[[PrimitiveValue]]: "hello"</span>\n<span class="hljs-comment">// }</span>\n\n<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">10</span>)); <span class="hljs-comment">// { [[PrimitiveValue]]: 12 }</span>\n</code></pre>\n<h3>Conclusion</h3>\n<p>Prototypes don\'t have to be magic. Once you learn how they work, it will explain a lot of the patterns that are out there. If you still don\'t understand how prototypes after reading this, that\'s normal. It took me a while before I finally understood them. Once you learn them though, you\'ll realize the concept is actually really simple! Keep on learning and you\'ll get them down!</p>\n<h3>Further Reading</h3>\n<p><a href="http://stackoverflow.com/questions/23807805/why-is-mutating-the-prototype-of-an-object-bad-for-performance">Why is mutating __proto__ bad</a></p>\n'}}],error:null,state:{projects:{codepen:[{title:"vue-scuffka",video:{url:"/_nuxt/videos/howitworks2.638279d.mp4"},thumbnail:{},icon:{xlinkHref:"icon-octocat"},fade:"white",href:"http://www.anthonykoch.com/vue-scuffka",meta:{},id:"cjk7he6aw0000zwyqjopzh7m2"},{title:"Calculator",image:{url:"/_nuxt/img/calculator.b6306cd.png"},thumbnail:{},icon:{xlinkHref:"icon-codepen-outline"},fade:"codepen",hash:"xVQOwb",href:"http://codepen.io/anthonykoch/pen/xVQOwb",meta:{likes:193},id:"cjk7he6aw0001zwyqwfbzfvec"},{title:"Settings Page",image:{url:"/_nuxt/img/settings.40eeba4.png"},thumbnail:{},icon:{xlinkHref:"icon-codepen-outline"},fade:"codepen",hash:"QjJaQv",href:"http://codepen.io/anthonykoch/pen/QjJaQv",meta:{likes:67},id:"cjk7he6aw0002zwyqyq4opsco"},{title:"Medium Image Loading",image:{url:"/_nuxt/img/medium.481d2f0.png"},thumbnail:{},icon:{xlinkHref:"icon-codepen-outline"},fade:"codepen",hash:"WrOQQz",href:"http://codepen.io/anthonykoch/pen/WrOQQz",meta:{likes:77},id:"cjk7he6aw0003zwyqbzydn729"},{title:"Smart Home UI",image:{url:"/_nuxt/img/smarthomeui.ed77829.png"},thumbnail:{},icon:{xlinkHref:"icon-codepen-outline"},fade:"codepen",hash:"GpQYrJ",href:"http://codepen.io/anthonykoch/pen/GpQYrJ",meta:{likes:37},id:"cjk7he6aw0004zwyqvt493ahk"},{title:"Social Connect",image:{url:"/_nuxt/img/social-connect.c9aeb13.png"},thumbnail:{},icon:{xlinkHref:"icon-codepen-outline"},fade:"codepen",hash:"MaQBrd",href:"http://codepen.io/anthonykoch/pen/MaQBrd",meta:{likes:46},id:"cjk7he6aw0005zwyqtobyapi0"}]},posts:{postsById:{},meta:[{excerpt:{content:"<p>Several months ago, I set out to get a deeper understanding of JavaScript, specifically in the area of prototypes. Prototypes were a fuzzy concept for me. I sort of knew how to use them, but didn't fully understand them. After a lot of study, I've started to see the picture of how prototypes work, and that they are not as complicated as I first thought.</p>\n",loc:{start:0,end:358}},layout:"post",author:"Anthony Koch",title:"Understanding JavaScript Prototypes",tags:["JavaScript","prototypes"],id:6,created_at:"2016-01-21T00:00:00.000Z",humanized:{created_at:"January, 20 2016"},url:"/blog/understanding-javascript-prototypes",slug:"understanding-javascript-prototypes"},{excerpt:{content:'<p>I was on the <a href="https://medium.com/">Medium</a> website and noticed a cool effect  they do when they lazy load their images. The image first appears blurry, and then slowly unblurs or fades out to reveal the actual image. I thought this was pretty cool, and wanted to see if I could achieve a similar effect.</p>\n',loc:{start:0,end:306}},layout:"post",author:"Anthony Koch",title:"Medium style image loading",tags:["stackblur","medium","lazy loading"],id:5,created_at:"2016-01-07T00:00:00.000Z",humanized:{created_at:"January, 6 2016"},url:"/blog/medium-style-images",slug:"medium-style-images"},{excerpt:{content:"<p>I had a friend ask me why you shouldn't iterate over arrays with a for-in loop, since after all, when he tried it everything worked as expected. Well, the reasoning for why you shouldn't do this is not immediately apparent, especially if you do not understand how property lookup and prototypes work.</p>\n",loc:{start:0,end:306}},layout:"post",author:"Anthony Koch",title:"Why you shouldn't loop arrays with for-in",tags:["JavaScript","arrays"],id:4,created_at:"2015-12-03T00:00:00.000Z",humanized:{created_at:"December, 2 2015"},url:"/blog/why-you-shouldnt-loop-arrays-with-for-in",slug:"why-you-shouldnt-loop-arrays-with-for-in"},{excerpt:{content:"<p>After an hour of research, trial, and error, I finally figured out how to get Con Emu to remember directories for tabs using Git Bash. When I first started using Con Emu, I swear it used to do this by default, but I guess updates in Con Emu or the Git Bash shell broke this feature. Either way, I've found a solution that worked for me to get this feature back.</p>\n",loc:{start:0,end:364}},layout:"post",author:"Anthony Koch",title:"Remember directories in Con Emu",tags:["con emu","command line"],id:3,created_at:"2015-11-15T00:00:00.000Z",humanized:{created_at:"November, 14 2015"},url:"/blog/remember-directories-in-con-emu",slug:"remember-directories-in-con-emu"},{excerpt:{content:"<p>This is an overview of some of the development tools I've found useful, as well as some opinions and experiences I have had with them.</p>\n",loc:{start:0,end:139}},layout:"post",author:"Anthony Koch",title:"The tools I use",tags:["development","tools"],id:2,created_at:"2015-08-21T00:00:00.000Z",humanized:{created_at:"August, 20 2015"},url:"/blog/the-tools-i-use",slug:"the-tools-i-use"},{excerpt:{content:"<p>ES2015, formerly called ES6, brings a lot of great features to JavaScript. A lot of the new features provide a much cleaner syntax for common tasks, and makes writing JavaScript so much better. After using these features for a while, I can't imagine going back to ES5. Here's an overview of my favorite features of ES2015.</p>\n",loc:{start:0,end:327}},layout:"post",author:"Anthony Koch",title:"My favorite features of ES2015",tags:["JavaScript","ES2015"],id:1,created_at:"2015-08-17T00:00:00.000Z",humanized:{created_at:"August, 16 2015"},url:"/blog/favorite-features-of-ES2015",slug:"favorite-features-of-ES2015"}]},navigation:{links:[{text:"work",href:"/#work",active:"/#work",scrollTo:"#work"},{text:"blog",href:"/blog",active:"/blog/"},{text:"contact",href:"/contact",active:"/contact/"}]},pages:{}},serverRendered:!0}</script><script src="/_nuxt/manifest.5665c98e4df93fca61f1.js" defer></script><script src="/_nuxt/layouts/default.678975d957cfa76f41ed.js" defer></script><script src="/_nuxt/pages/blog/_slug.144bb6835d0d840d4d5c.js" defer></script><script src="/_nuxt/vendor.7d001ce926a227b17f6c.js" defer></script><script src="/_nuxt/app.6fd2de9b8344bde49f5d.js" defer></script>
  

