{
  "excerpt": {
    "content": "<p>Several months ago, I set out to get a deeper understanding of JavaScript, specifically in the area of prototypes. Prototypes were a fuzzy concept for me. I sort of knew how to use them, but didn't fully understand them. After a lot of study, I've started to see the picture of how prototypes work, and that they are not as complicated as I first thought.</p>\n",
    "loc": {
      "start": 0,
      "end": 363
    }
  },
  "author": "Anthony Koch",
  "title": "Understanding JavaScript Prototypes",
  "tags": [
    "JavaScript",
    "prototypes"
  ],
  "id": 6,
  "created_at": "2016-01-21T00:00:00.000Z",
  "humanized": {
    "created_at": "January, 20 2016"
  },
  "url": "/blog/understanding-javascript-prototypes",
  "slug": "understanding-javascript-prototypes",
  "next": {
    "url": "/blog/just-nuxt-things",
    "author": "Anthony Koch",
    "title": "Just Nuxt Things",
    "tags": [
      "nuxt",
      "vue",
      "webpack"
    ],
    "id": 7,
    "created_at": "2018-07-29T00:00:00.000Z"
  },
  "previous": {
    "url": "/blog/medium-style-images",
    "author": "Anthony Koch",
    "title": "Medium style image loading",
    "tags": [
      "stackblur",
      "medium",
      "lazy loading"
    ],
    "id": 5,
    "created_at": "2016-01-07T00:00:00.000Z"
  },
  "contents": "<p>Several months ago, I set out to get a deeper understanding of JavaScript, specifically in the area of prototypes. Prototypes were a fuzzy concept for me. I sort of knew how to use them, but didn't fully understand them. After a lot of study, I've started to see the picture of how prototypes work, and that they are not as complicated as I first thought.</p>\n<!-- endexcerpt -->\n<h3 id=\"what-is-a-prototype\">What is a prototype?</h3>\n<p>Some confusion may arise when talking about prototypes because the word &quot;prototype&quot; may be used to describe the internal <code>[[Prototype]]</code> property of an object, or the <code>prototype</code> property of a function. These are two separate things, but later on we'll see that they relate.</p>\n<h4 id=\"internal-prototype\">Internal prototype</h4>\n<p>Strings, numbers, booleans, objects, arrays, and functions are created with an internal <code>[[Prototype]]</code> property. The value of this property is an object, whose purpose purpose will be explained later. Since this property is internal, it is not exposed to us through the code we write. However, when the fifth version of EcmaScript came along, the specification did allow the retrieval of this internal property with <code>Object.getPrototypeOf</code>.</p>\n<p>Some time later, browsers started implementing a property called  <code>__proto__</code>, which allows both reading and writing of an object's internal <code>[[Prototype]]</code> property. It's important to know that the use of this property is <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto\">highly discouraged</a>, and an alternative is explained later on. The <code>__proto__</code> property is only used here in examples as it provides a better illustration.</p>\n<p>Also, it's important to remember that both <code>Object.getPrototypeOf</code> and the <code>__proto__</code> property return the internal <code>[[Prototype]]</code> of an object. So, when I say <code>[[Prototype]]</code>, I'm referring to the object returned from <code>Object.getPrototypeOf</code> or <code>__proto__</code>.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">var</span> bob = {};\n<span class=\"hljs-keyword\">var</span> str = <span class=\"hljs-string\">'Hello'</span>;\n<span class=\"hljs-keyword\">var</span> num = <span class=\"hljs-number\">123</span>;\n\n<span class=\"hljs-comment\">// They all have a [[Prototype]], which we can retrieve with __proto__</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">typeof</span> bob.__proto__); <span class=\"hljs-comment\">// 'object'</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">typeof</span> str.__proto__); <span class=\"hljs-comment\">// 'object'</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">typeof</span> num.__proto__); <span class=\"hljs-comment\">// 'object'</span>\n\n<span class=\"hljs-comment\">// we can also retrieve it with Object.getPrototypeOf</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">Object</span>.getPrototypeOf(bob) === bob.__proto__); <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<h4 id=\"function-prototype\">Function prototype</h4>\n<p>Functions are created with a property called <code>prototype</code>, whose value is an object. Most people have probably found themselves using this property at some point. It is a common pattern to assign what are commonly called &quot;methods&quot;, which are functions, or other values to this object, and then use the function as constructor, meaning the function is called with <code>new</code>. When the function is called with <code>new</code>, an object is returned that inherits the properties of the constructor's <code>prototype</code> object. This is called the &quot;constructor&quot; pattern.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// Person is the constructor</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span>(<span class=\"hljs-params\"></span>) </span>{\n\n}\n\n<span class=\"hljs-comment\">// The prototype property is a normal object</span>\n<span class=\"hljs-built_in\">console</span>.log(Person.prototype); <span class=\"hljs-comment\">// {}</span>\n\nPerson.prototype.eatFood = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n\t<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'scrumptious!'</span>);\n};\n\n<span class=\"hljs-keyword\">var</span> bob = <span class=\"hljs-keyword\">new</span> Person();\n\n<span class=\"hljs-comment\">// bob is an object that \"inherits\" the eatFood function</span>\nbob.eatFood(); <span class=\"hljs-comment\">// 'scrumptious!'</span>\n</code></pre>\n<p>The <code>eatFood</code> function was assigned to the <code>Person.prototype</code> object, but we can access it on <code>bob</code>. So, why does assigning values to the <code>prototype</code> object allow us to then access those values on objects returned from the constructor? Well, there are two parts to this:</p>\n<ol>\n<li>What happens in the constructor when the object is created.</li>\n<li>How properties are resolved.</li>\n</ol>\n<h3 id=\"constructor-functions\">Constructor functions</h3>\n<p>A constructor, according to the EcmaScript <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-15\">spec</a>, is a function that is meant for use with the <code>new</code> operator. There's nothing special about them; they're just functions. Normally, the name of the function is written in Pascal casing, but this is just a convention programmers use to signify that the function is intended to be used with the <code>new</code> operator.</p>\n<p>When you call a function with the <code>new</code> operator, the function runs as it normally would, except the value of <code>this</code> is set to a newly created object, and the object created has its <code>[[Prototype]]</code> set to the <code>prototype</code> object of the constructor. After the code inside the function finishes, the newly created object is returned.</p>\n<p>Below is an example of what happens in the background when a function is called with the <code>new</code> operator. The code below wouldn't actually run because assigning a value to <code>this</code> would generate a syntax error, but the code would otherwise run just fine.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span>(<span class=\"hljs-params\"></span>) </span>{\n\t<span class=\"hljs-comment\">// Set \"this\" to a new object</span>\n\t<span class=\"hljs-keyword\">var</span> <span class=\"hljs-keyword\">this</span> = {};\n\t<span class=\"hljs-comment\">// Set the [[Prototype]] of the object to the constructor's prototype</span>\n\t<span class=\"hljs-keyword\">this</span>.__proto__ = Person.prototype;\n\n\t<span class=\"hljs-comment\">// The code defined in the function would run at this point</span>\n\n\t<span class=\"hljs-comment\">// return the object</span>\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;\n}\n\nPerson.prototype.eatFood = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n\t<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'scrumptious!'</span>);\n};\n\n<span class=\"hljs-keyword\">var</span> bob = <span class=\"hljs-keyword\">new</span> Person();\nbob.eatFood(); <span class=\"hljs-comment\">// 'scrumptious!'</span>\n\n<span class=\"hljs-comment\">// Bob's [[Prototype]] is Person.prototyope</span>\n<span class=\"hljs-built_in\">console</span>.log(bob.__proto__ === Person.prototype); <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p><strong>Note:</strong> You can find this process in the ES5 spec <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-13.2.2\">here</a>.</p>\n<p>This setting of the newly created object's <code>[[Prototype]]</code> to its constructor's <code>protototype</code> object is the same thing that happens for strings, numbers, booleans, objects, arrays, and functions. They all have their <code>[[Prototype]]</code> set to the <code>prototype</code> property of their associated constructor.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// An object's [[Prototype]] is Object.prototype</span>\n<span class=\"hljs-built_in\">console</span>.log({}.__proto__ === <span class=\"hljs-built_in\">Object</span>.prototype); <span class=\"hljs-comment\">// true</span>\n\n<span class=\"hljs-comment\">// An array's [[Prototype]] is Array.prototype</span>\n<span class=\"hljs-built_in\">console</span>.log([].__proto__ === <span class=\"hljs-built_in\">Array</span>.prototype); <span class=\"hljs-comment\">// true</span>\n\n<span class=\"hljs-comment\">// A string's [[Prototype]] is String.prototype</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Hello'</span>.__proto__ === <span class=\"hljs-built_in\">String</span>.prototype); <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p>This is how the <code>[[Prototype]]</code> of an object relates to the <code>prototype</code> of its constructor, they're the same object. Although this is true, this doesn't explain how we can set the function <code>eatFood</code> on <code>Person.prototype</code>, and be able to call it on <code>bob</code>. This brings in the second part, which is property lookup.</p>\n<h3 id=\"property-lookup\">Property lookup</h3>\n<p>When a property isn't found on the object in question, the property lookup goes from the object to its <code>[[Prototype]]</code> object. From the earlier example of the <code>Person</code> constructor, we can see that the constructor sets <code>bob</code>'s <code>[[Prototype]]</code> to its <code>prototype</code> object. Therefore, when accessing a property on <code>bob</code> that <code>bob</code> doesn't have, the property lookup will go to the <code>Person.prototype</code> object.</p>\n<p>If the <code>Person.prototype</code> object didn't have the property, the property lookup would go to the <code>[[Prototype]]</code> of the <code>Person.prototype</code> object, which would be <code>Object.prototype</code>. If <code>Object.prototype</code> didn't have the property we would check its <code>[[Prototype]]</code>. However, <code>Object.prototype</code> has its <code>[[Prototype]]</code> explicitly set to null, the purpose being that the property lookup is supposed to end there, since the spec says when a <code>[[Prototype]]</code> that is null is reached, the property lookup ends and <code>undefined</code> should be returned in place of the property's value.</p>\n<p><strong>Note:</strong> If you're interested, you can read about the property lookup operations in the ES5 spec <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-8.12.2\">here</a>.</p>\n<pre class=\"hljs\"><code>The prototype chain <span class=\"hljs-keyword\">of</span> bob\n\n             Person.prototype               <span class=\"hljs-built_in\">Object</span>.prototype\n                   |                              |\nbob   -&gt;   bob.__proto__   -&gt;   bob.__proto__.__proto__\n</code></pre>\n<p>So, the purpose of the <code>[[Prototype]]</code> is as a delegate for property lookup in the case the original object doesn't have the property. In essence, it's another place to look for the properties of an object.</p>\n<p>An important thing to realize here is that the property lookup doesn't go from the object, to its constructor, and then to the constructor's <code>prototype</code> object. The property lookup goes from the object to whatever is set as its <code>[[Prototype]]</code>. We could at anytime change the value of <code>Person</code>'s <code>prototype</code> property to something else, and <code>bob</code>'s <code>[[Prototype]]</code> would still point to the constructor's original <code>prototype</code> object, because that's what <code>bob</code> was initialized with.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span>(<span class=\"hljs-params\"></span>) </span>{}\n<span class=\"hljs-keyword\">var</span> originalPrototype = Person.prototype;\n\n<span class=\"hljs-comment\">// Bob has its linking to the original prototype</span>\n<span class=\"hljs-keyword\">var</span> bob = <span class=\"hljs-keyword\">new</span> Person();\n\nPerson.prototype = {};\n\n<span class=\"hljs-comment\">// Bob doesn't link to Person's new prototype</span>\n<span class=\"hljs-built_in\">console</span>.log(bob.__proto__ === Person.prototype);  <span class=\"hljs-comment\">// false</span>\n\n<span class=\"hljs-comment\">// Bob's `[[Prototype]]` is still the original Person.prototype object</span>\n<span class=\"hljs-built_in\">console</span>.log(bob.__proto__ === originalPrototype); <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p>This is why you'll hear sayings such as &quot;objects link to other objects&quot;. Objects are directly linked together through their <code>[[Prototype]]</code>, meaning the constructor is actually extraneous. <code>bob</code> links directly to another object, that object being <code>Person.prototype</code>, and <code>Person.prototype</code> links directly to another object, that object being <code>Object.prototype</code>.</p>\n<p>Now, knowing how property lookup works, we should be able to see this property lookup delegation at work if we were to put a property on <code>Object.prototype</code>. Since mostly all objects have a prototype chain that leads back to <code>Object.prototype</code>, we should be to access it on to strings, numbers, objects, arrays, etc.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-built_in\">Object</span>.prototype.coolStuff = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n\t<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Really cool'</span>);\n};\n\n({}).coolStuff();     <span class=\"hljs-comment\">// 'really cool'</span>\n[].coolStuff();       <span class=\"hljs-comment\">// 'really cool'</span>\n<span class=\"hljs-string\">''</span>.coolStuff();       <span class=\"hljs-comment\">// 'really cool'</span>\n(<span class=\"hljs-number\">123</span>).coolStuff();    <span class=\"hljs-comment\">// 'really cool'</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">eatFood</span>(<span class=\"hljs-params\"></span>) </span>{}\neatFood.coolStuff();  <span class=\"hljs-comment\">// 'really cool'</span>\n\n<span class=\"hljs-built_in\">Object</span>.prototype.coolStuff.coolStuff(); <span class=\"hljs-comment\">// 'really cool'</span>\n</code></pre>\n<p>The last one, where we call <code>coolStuff</code> as a property of itself, works because <code>coolStuff</code> has its <code>[[Prototype]]</code> set to <code>Function.prototype</code>. Since <code>Function.prototype</code> doesn't have a property with the name of <code>coolStuff</code>, the property lookup goes to the <code>[[Prototype]]</code> of <code>Function.prototype</code>, which is <code>Object.prototype</code>. Since <code>Object.prototype</code> has a property named <code>coolStuff</code>, the value for the property is returned.</p>\n<pre><code>The prototype chain of coolStuff\n\n      Function.prototype                     Object.prototype\n              |                                    |\ncoolStuff.__proto__   -&gt;   coolStuff.__proto__.__proto__\n</code></pre>\n<p>As another fun example, we'll set a property on <code>Object.prototype</code> that has a  number as the key, and then access the same key on an array.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">var</span> arr = [];\n<span class=\"hljs-built_in\">Object</span>.prototype[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-string\">'tomatoes'</span>;\n<span class=\"hljs-built_in\">console</span>.log(arr[<span class=\"hljs-number\">0</span>]);\n\n<span class=\"hljs-keyword\">var</span> names = [<span class=\"hljs-string\">'John'</span>, <span class=\"hljs-string\">'Bob'</span>, <span class=\"hljs-string\">'Jim'</span>];\n<span class=\"hljs-built_in\">console</span>.log(names[<span class=\"hljs-number\">0</span>]);\n</code></pre>\n<p>What do you think will be logged to the console with <code>arr[0]</code>? If your answer is <code>tomatoes</code>, you'd be correct! Array indices are properties, and resolve in the same way properties do. The property lookup goes from the array, to <code>Array.prototype</code>, and then to <code>Object.prototype</code>.</p>\n<p>What do you think will be logged to the console with <code>names[0]</code>? If you guessed <code>John</code>, you'd also be correct. Since the <code>names</code> array has a property with the name of <code>0</code>, there is no need to check the prototype chain.</p>\n<h3 id=\"prototypes-without-constructors\">Prototypes without constructors</h3>\n<p>The examples before show objects having a <code>[[Prototype]]</code> such as <code>String.prototype</code> and <code>Person.prototype</code>, where <code>String</code> and <code>Person</code> are constructor functions. But, as was mentioned before, constructors are extraneous and aren't actually necessary for inheritance to take place. The only parts necessary are two objects, and all we have to do is set one object as the <code>[[Prototype]]</code> of the other object.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">var</span> bob = {};\n<span class=\"hljs-keyword\">var</span> person = {\n\t<span class=\"hljs-attr\">eatFood</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n\t\t<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'scrumptious!'</span>);\n\t}\n};\n\n<span class=\"hljs-comment\">// Sets person as the [[Prototype]] of bob</span>\nbob.__proto__ = person;\n\n<span class=\"hljs-comment\">// bob can still eat his food</span>\nbob.eatFood(); <span class=\"hljs-comment\">// 'scrumptious!'</span>\n</code></pre>\n<p>In the above example, <code>person</code> is set as the <code>[[Prototype]]</code> of <code>bob</code>, meaning <code>bob</code> will now delegate property access to <code>person</code> when <code>bob</code> itself doesn't have the property.</p>\n<p><strong>Note:</strong> Although this would produce the intended result, assigning to the <code>__proto__</code> property in this way is <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto\">highly discouraged</a>. The safe way to set the <code>[[Prototype]]</code> of an object is with <code>Object.create</code>.</p>\n<h4 id=\"object-create\">Object.create</h4>\n<p><code>Object.create</code> is a function that simply creates an object and sets the object's <code>[[Prototype]]</code> to what is passed as the first argument. It also allows defining new properties on the object, but we won't focus on that here.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">var</span> person = {\n\t<span class=\"hljs-attr\">eatFood</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n\t\t<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'scrumptious!'</span>);\n\t}\n};\n\n<span class=\"hljs-keyword\">var</span> bob = <span class=\"hljs-built_in\">Object</span>.create(person);\n\n<span class=\"hljs-comment\">// Bob's [[Prototype]] is set to person</span>\n<span class=\"hljs-built_in\">console</span>.log(bob.__proto__ === person); <span class=\"hljs-comment\">// true</span>\nbob.eatFood(); <span class=\"hljs-comment\">// 'scrumptious!'</span>\n</code></pre>\n<p>With this comes the prototypal design pattern. Some may say this pattern &quot;creates objects from other objects&quot;, but in my opinion, this isn't really accurate, since what's happening is we're just creating a new, arbitrary object, and settings its <code>[[Prototype]]</code> to another object. There isn't really a creation from another object. There isn't a copying of another object. There's just an object, which delegates property lookup to its <code>[[Prototype]]</code> object, and so on through its prototype chain.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// The functionality representing a person</span>\n<span class=\"hljs-keyword\">var</span> person = {\n\t<span class=\"hljs-attr\">eatFood</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n\t\t<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'scrumptious!'</span>);\n\t}\n};\n\n<span class=\"hljs-comment\">// The functionality representing a salesman</span>\n<span class=\"hljs-keyword\">var</span> salesman = <span class=\"hljs-built_in\">Object</span>.create(person);\n<span class=\"hljs-comment\">// We then extend salesman to have the functionality it needs</span>\nsalesman.sellThings = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n\t<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'I am selling things'</span>);\n}\n\n<span class=\"hljs-comment\">// We can then create objects that have the functionality of a person and salesman</span>\n<span class=\"hljs-keyword\">var</span> bob = <span class=\"hljs-built_in\">Object</span>.create(salesman);\nbob.sellThings(); <span class=\"hljs-comment\">// 'I am selling things'</span>\nbob.eatFood(); <span class=\"hljs-comment\">// 'scrumptious!'</span>\n\n<span class=\"hljs-comment\">// We can then set properties onto bob as needed</span>\nbob.firstName = <span class=\"hljs-string\">'bob'</span>;\n\n<span class=\"hljs-comment\">// The prototype chain of bob looks like this:</span>\n\n     salesman   person  <span class=\"hljs-built_in\">Object</span>.prototype\n        |         |          |\nbob.__proto__.__proto__.__proto__\n</code></pre>\n<h4 id=\"comparing-object-create-and-constructors\">Comparing Object.create and constructors</h4>\n<p>If we compare the simplified illustration of what happens in the background of a constructor call and a simplified version of <code>Object.create</code>, we would see some similarities.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span>(<span class=\"hljs-params\"></span>) </span>{\n\t<span class=\"hljs-comment\">// Create a new object</span>\n\t<span class=\"hljs-keyword\">var</span> <span class=\"hljs-keyword\">this</span> = {};\n\t<span class=\"hljs-comment\">// Set the object's [[Prototype]]</span>\n\t<span class=\"hljs-keyword\">this</span>.__proto__ = Person.prototype;\n\n\t<span class=\"hljs-comment\">// The code in the function would run at this point</span>\n\n\t<span class=\"hljs-comment\">// Return the object</span>\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;\n}\n\n<span class=\"hljs-built_in\">Object</span>.create = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">prototype</span>) </span>{\n\t<span class=\"hljs-comment\">// Create a new object</span>\n\t<span class=\"hljs-keyword\">var</span> obj = {};\n\t<span class=\"hljs-comment\">// Set the object's [[Prototype]]</span>\n\tobj.__proto__ = prototype;\n\n\t<span class=\"hljs-comment\">// Return the object</span>\n\t<span class=\"hljs-keyword\">return</span> obj;\n};\n</code></pre>\n<p>They both create a new object, and then set the <code>[[Prototype]]</code> of the new object to another object, which sets up the environment to allow property delegation to work. So, constructors are more like factories, returning objects pre-linked to another object, and the linking just happens to be to the constructor's <code>prototype</code> object.</p>\n<p>Now, you may say, &quot;That's not the Object.create polyfill I've seen elsewhere!&quot;. That's true, it's not. If we were to look at a polyfill for <code>Object.create</code> we would see the following.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-built_in\">Object</span>.create = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">proto, properties</span>) </span>{\n\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> proto !== <span class=\"hljs-string\">'object'</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> proto !== <span class=\"hljs-literal\">null</span>) {\n\t\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'Object prototype may only be an Object or null'</span>);\n\t}\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Temp</span>(<span class=\"hljs-params\"></span>) </span>{}\n\tTemp.prototype = proto;\n\n\t<span class=\"hljs-comment\">// Create the new object</span>\n\t<span class=\"hljs-keyword\">var</span> obj = <span class=\"hljs-keyword\">new</span> Temp();\n\n\tObjectDefineProperties(obj, properties);\n\n\t<span class=\"hljs-keyword\">return</span> obj;\n};\n</code></pre>\n<p>The reason why a constructor is used in the actual polyfill instead of <code>__proto__</code> is because assigning to <code>__proto__</code> brings performance hits, and may not entirely be cross browser. The only way to create an object with a specific <code>[[Prototype]]</code> in older browsers is with a constructor function.</p>\n<p>If we look at the definition of <code>Object.create</code> in NodeJS, we would see that it doesn't use a constructor function (code obtained from the <a href=\"https://github.com/nodejs/node/blob/db9e122182f7e605eba2eb2e9ddea0bf00bb572c/deps/v8/src/js/v8natives.js#L1017\">NodeJS github repository</a>).</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// ES5 section 15.2.3.5.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ObjectCreate</span>(<span class=\"hljs-params\">proto, properties</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (!IS_SPEC_OBJECT(proto) &amp;&amp; proto !== <span class=\"hljs-literal\">null</span>) {\n    <span class=\"hljs-keyword\">throw</span> MakeTypeError(kProtoObjectOrNull, proto);\n  }\n  <span class=\"hljs-keyword\">var</span> obj = {};\n  %InternalSetPrototype(obj, proto);\n  <span class=\"hljs-keyword\">if</span> (!IS_UNDEFINED(properties)) ObjectDefineProperties(obj, properties);\n  <span class=\"hljs-keyword\">return</span> obj;\n}\n</code></pre>\n<p>There's no constructor function here. It literally just creates a new, empty object, and sets the newly created object's <code>[[Prototype]]</code> with some sort of internal function.</p>\n<h4 id=\"creating-objects-without-prototypes\">Creating objects without prototypes</h4>\n<p>When <code>Object.create</code> is passed <code>null</code>, the object returned will have no object set as its <code>[[Prototype]]</code>. I have yet to find a use case for this, but it's interesting nonetheless.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">var</span> bob = <span class=\"hljs-built_in\">Object</span>.create(<span class=\"hljs-literal\">null</span>);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">Object</span>.getPrototypeOf(bob)); <span class=\"hljs-comment\">// null</span>\n\nbob.toString(); <span class=\"hljs-comment\">// TypeError: bob.toString is not a function</span>\n</code></pre>\n<p>If we try to call the <code>toString</code> property of <code>bob</code>, we'll get a TypeError saying &quot;bob.toString is not a function&quot;. This is because the <code>toString</code> property is defined on <code>Object.prototype</code>, but since <code>bob</code> has a <code>[[Prototype]]</code> that is <code>null</code>, the property lookup has nowhere to go, which means it can't reach <code>Object.prototype</code>. As a result, the property lookup returns <code>undefined</code>, which of course is not callable, hence &quot;bob.toString is not a function&quot;.</p>\n<h3 id=\"constructors-classes-and-prototypal-patterns\">Constructors, classes, and prototypal patterns</h3>\n<p>It doesn't matter which pattern you choose, whether it be the constructor pattern, classes, the prototypal pattern, or any other pattern that claims &quot;inheritance&quot; in JavaScript. They <strong>all</strong> use the same underlying mechanism, which is the delegation of property lookup through an object's prototype chain.</p>\n<h3 id=\"primitive-prototypes\">Primitive prototypes</h3>\n<p>I have referred to strings, numbers, and booleans as objects, and that we can access properties on them, but this is not technically true. Strings, numbers, and booleans are primitives, and they themselves don't have properties. When accessing a property on a value that is a primitive, the JS engine wraps the primitive in an object wrapper. For example, a number would be wrapped in a Number object wrapper, and a string would be wrapped in a String object wrapper. This process is called &quot;boxing and unboxing&quot;.</p>\n<p>So, when I call numbers, strings, and booleans objects, I'm referring to their object wrappers. The wrappers are the ones that we are accessing properties on, not the primitive itself.</p>\n<p><strong>Note:</strong> The function that wraps primitives in their object wrappers can be found <a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-9.9\">here</a>.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// so this</span>\n<span class=\"hljs-string\">'hello'</span>.__proto__\n<span class=\"hljs-comment\">// is turned into this by the JS engine automatically</span>\n<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-string\">'hello'</span>).__proto__\n\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-string\">'hello'</span>));\n<span class=\"hljs-comment\">// {</span>\n<span class=\"hljs-comment\">// \t0: \"h\",</span>\n<span class=\"hljs-comment\">//  1: \"e\",</span>\n<span class=\"hljs-comment\">//  2: \"l\",</span>\n<span class=\"hljs-comment\">//  3: \"l\",</span>\n<span class=\"hljs-comment\">//  4: \"o\",</span>\n<span class=\"hljs-comment\">// \tlength: 5,</span>\n<span class=\"hljs-comment\">// \t[[PrimitiveValue]]: \"hello\"</span>\n<span class=\"hljs-comment\">// }</span>\n\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-number\">10</span>)); <span class=\"hljs-comment\">// { [[PrimitiveValue]]: 12 }</span>\n</code></pre>\n<h3 id=\"conclusion\">Conclusion</h3>\n<p>Prototypes don't have to be magic. Once you learn how they work, it will explain a lot of the patterns that are out there. If you still don't understand how prototypes after reading this, that's normal. It took me a while before I finally understood them. Once you learn them though, you'll realize the concept is actually really simple! Keep on learning and you'll get them down!</p>\n<h3 id=\"further-reading\">Further Reading</h3>\n<p><a href=\"http://stackoverflow.com/questions/23807805/why-is-mutating-the-prototype-of-an-object-bad-for-performance\">Why is mutating __proto__ bad</a></p>\n"
}